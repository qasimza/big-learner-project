"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var src_exports = {};
__export(src_exports, {
  default: () => suidPlugin,
  transform: () => transform
});
module.exports = __toCommonJS(src_exports);
var import_generator = __toESM(require("@babel/generator"), 1);
var import_parser = require("@babel/parser");
var import_traverse = __toESM(require("@babel/traverse"), 1);
var types = __toESM(require("@babel/types"), 1);
const traverse = import_traverse.default.default;
const generate = import_generator.default.default;
const defaultOptions = {
  disableOptimizeDeps: [
    "@suid/base",
    "@suid/codemod",
    "@suid/css",
    "@suid/icons-material",
    "@suid/material",
    "@suid/styled-engine",
    "@suid/system",
    "@suid/types",
    "@suid/utils"
  ],
  optimizeImports: {
    enabled: true,
    paths: ["@suid/icons-material", "@suid/material"]
  },
  parserOptions: {
    sourceType: "module",
    plugins: ["jsx", "typescript"]
  }
};
function suidPlugin(inOptions = {}) {
  const options = {
    ...defaultOptions,
    ...inOptions,
    parserOptions: {
      ...defaultOptions.parserOptions,
      ...inOptions.parserOptions
    },
    optimizeImports: {
      ...defaultOptions.optimizeImports,
      ...inOptions.optimizeImports
    }
  };
  return {
    name: "suid",
    config: (config) => {
      const solidDeps = options.disableOptimizeDeps || [];
      return {
        optimizeDeps: {
          exclude: [...config.optimizeDeps?.exclude || [], ...solidDeps]
        },
        ssr: {
          ...config.ssr,
          noExternal: [
            ...Array.isArray(config.ssr?.noExternal) ? (
              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
              config.ssr.noExternal
            ) : [],
            ...solidDeps
          ]
        }
      };
    },
    transform(code) {
      const transformIconImportsOptions = options.optimizeImports || {};
      if (transformIconImportsOptions.enabled && transformIconImportsOptions.paths?.some((p) => code.includes(p))) {
        return transform(code, options);
      }
    }
  };
}
function isCapitalized(value) {
  return value[0].toUpperCase() === value[0];
}
function isMaterialStylesImport(value) {
  return !["useMediaQuery"].includes(value) && (["StyledEngineProvider", "Breakpoint", "ThemeProvider", "Theme"].includes(
    value
  ) || !isCapitalized(value));
}
function getOptimizedImportPath(source, name, alias) {
  if (source === "@suid/material") {
    if (isMaterialStylesImport(name)) {
      return {
        specifier: {
          [name]: alias
        },
        path: `${source}/styles`
      };
    }
  }
  return {
    specifier: alias,
    path: `${source}/${name}`
  };
}
function transform(code, options) {
  const ast = (0, import_parser.parse)(code, options.parserOptions);
  traverse(ast, {
    enter(path) {
      const { node } = path;
      const optimize = types.isImportDeclaration(node) && // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      options.optimizeImports.paths.some((v) => v === node.source.value);
      if (!optimize)
        return;
      const imports = node.specifiers.map((spec) => {
        if (types.isImportSpecifier(spec) && types.isIdentifier(spec.imported) && types.isIdentifier(spec.local)) {
          return getOptimizedImportPath(
            node.source.value,
            spec.imported.name,
            spec.local.name
          );
        }
      }).filter((v) => !!v);
      path.replaceWithMultiple(
        imports.map(
          (item) => types.importDeclaration(
            typeof item.specifier === "string" ? [types.importDefaultSpecifier(types.identifier(item.specifier))] : [
              ...Object.entries(item.specifier).map(
                ([alias, specifier]) => types.importSpecifier(
                  types.identifier(specifier),
                  types.identifier(alias)
                )
              )
            ],
            types.stringLiteral(item.path)
          )
        )
      );
    }
  });
  return generate(ast);
}
